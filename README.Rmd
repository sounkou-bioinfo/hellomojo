---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  fig.path = "docs/README-"
)
```
# hellomojo

An Example R Package that Uses 'mojo' Through the `.Call` Interface 

## Overview

This package provides a setup to call [Mojo](https://www.modular.com/mojo) code from R using the mojo shared library build mode. This was obviously designed for python interop. If we only use simple types, we can call mojo using the `.Call` interface. Some boilerplate is required, but this can be automated.

## How It Works ?

Mojo code is compiled to a shared library, in our case `libhello.so`. A C file [`RC_hellomojo.c`](src/RC_hellomojo.c) provides wrappers and registration so R can call the Mojo functions via the `.Call` interface. R functions like `hellomojo()` call the native code using `.Call()`(can t see the hello world in the Readme bc it is written in C stdout). The [`configure`](configure) script uses [pixi](https://pixi.sh/) to install mojo and run the shared library build.

## Example

```{r}
# Load the package and call the native function
hellomojo::hellomojo()
hellomojo::hellomojo_add(10, 30)
```

the mojo code

```{r engine='bash', comment=''}
cat inst/mojo/hellomojo/hellomojo.mojo
```

the C wrappers

```{r engine='bash', comment=''}
cat src/RC_hellomojo.c
```



## Convolution Example and Benchmark

The classic convolution benchmark 

```{r}
# Example data
signal <- rnorm(1000)
kernel <- c(0.2, 0.5, 0.3)

# Mojo convolution
mojo_result <- hellomojo::hellomojo_convolve(signal, kernel)

# C convolution using callme
code <- '
  SEXP c_convolve(SEXP signal, SEXP kernel) {
    R_xlen_t n_signal = XLENGTH(signal);
    R_xlen_t n_kernel = XLENGTH(kernel);
    R_xlen_t n_out = n_signal - n_kernel + 1;
    SEXP out = PROTECT(allocVector(REALSXP, n_out));
    double *sig = REAL(signal);
    double *ker = REAL(kernel);
    double *o = REAL(out);
    for (R_xlen_t i = 0; i < n_out; ++i) {
      double acc = 0.0;
      for (R_xlen_t j = 0; j < n_kernel; ++j) {
        acc += sig[i + j] * ker[j];
      }
      o[i] = acc;
    }
    UNPROTECT(1);
    return out;
  }'
callme::compile(code)
c_result <- c_convolve(signal, kernel)

# Check results are similar
print(all.equal(as.numeric(mojo_result), as.numeric(c_result)))

# Benchmark
bench::mark(
        mojo = hellomojo::hellomojo_convolve(signal, kernel),
        c = c_convolve(signal, kernel),
        check = FALSE
)    
  
```

## Limitations to investigate

Of course here we are using pixi to get Mojo binaries, installing 
this on the R windows toolchain is not given. We should use uv or make a R package that install pix. Moreover i could not add windown to the current pixi workspace. This package should work fine on unix. Moreover we are calling the mojo shared object in the same address space as R even though the toolchains were different.

Additionally we have an additional C wrapping which may be not required if we pass the data directly to the mojo C callables.


## References

- [Mojo Getting Started Guide](https://docs.modular.com/mojo/manual/get-started)  
- [pixi: Package and Environment Manager](https://pixi.sh/)
- [simpleCall example](https://github.com/coolbutuseless/simpleCall)