---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  fig.path = "docs/README-"
)
```
# hellomojo

An Example R Package that Uses 'mojo' Through the `.Call` Interface 

## Overview

This package provides a setup to call [Mojo](https://www.modular.com/mojo) code from R using the mojo shared library build mode. This was obviously designed for python interop. If we only use simple types, we can call mojo using the `.Call` interface. Some boilerplate is required, but this can be automated.

## How It Works ?

Mojo code is compiled to a shared library, in our case `libhello.so`. A C file [`RC_hellomojo.c`](src/RC_hellomojo.c) provides wrappers and registration so R can call the Mojo functions via the `.Call` interface. R functions like `hellomojo()` call the native code using `.Call()` and R C API can be called (somehow unsafely from Mojo). The [`configure`](configure) script uses [pixi](https://pixi.sh/) to install mojo and run the shared library build.

## Installation

By default, the package installs without Mojo installation via pixi

```r
install.packages('hellomojo', repos = c('https://sounkou-bioinfo.r-universe.dev', 'https://cloud.r-project.org'))
```

To enable compiling the Mojo functions with the RC code, set `HELLOMOJO_BUILD=1` before installation. The configure script will automatically install pixi and compile the hellomojo shared library:

```r
Sys.setenv(HELLOMOJO_BUILD = "1")
install.packages('hellomojo', repos = c('https://sounkou-bioinfo.r-universe.dev', 'https://cloud.r-project.org'))
```

For dynamic compilation workflows similar to `callme::compile()`, install Mojo in a virtual environment first:

```r
mojo_install(venv = ".venv/mojo", nightly = TRUE)
mojo_compile("inst/mojo/hellomojo/hellomojo.mojo", venv = ".venv/mojo")
```


## Example with pre-compiled native functions

```{r}
# Load the package and call the native function
hellomojo::hellomojo()
hellomojo::hellomojo_add(10, 30)

# Get comprehensive system and device information (CPU + GPU when available)
# hellomojo::hellomojo_device_info(device_id = 0L, api_name = "cuda")
```

the mojo code

```{r engine='bash', comment=''}
cat inst/mojo/hellomojo/hellomojo.mojo
```

the C wrappers

```{r engine='bash', comment=''}
cat src/RC_hellomojo.c
```



## Convolution Example and Benchmark

The classic convolution benchmark 

```{r}
# Example data
signal <- rnorm(10000)
kernel <- c(0.2, 0.5, 0.3)

# Mojo convolution
mojo_result <- hellomojo::hellomojo_convolve(signal, kernel)

# C convolution using callme
code <- '
  SEXP c_convolve(SEXP signal, SEXP kernel) {
    R_xlen_t n_signal = XLENGTH(signal);
    R_xlen_t n_kernel = XLENGTH(kernel);
    R_xlen_t n_out = n_signal - n_kernel + 1;
    SEXP out = PROTECT(allocVector(REALSXP, n_out));
    double *sig = REAL(signal);
    double *ker = REAL(kernel);
    double *o = REAL(out);
    for (R_xlen_t i = 0; i < n_out; ++i) {
      double acc = 0.0;
      for (R_xlen_t j = 0; j < n_kernel; ++j) {
        acc += sig[i + j] * ker[j];
      }
      o[i] = acc;
    }
    UNPROTECT(1);
    return out;
  }'
callme::compile(code)
c_result <- c_convolve(signal, kernel)

# Check results are similar
print(all.equal(as.numeric(mojo_result), as.numeric(c_result)))
mojo_result |> head()
# Benchmark
bench::mark(
        mojo = hellomojo::hellomojo_convolve(signal, kernel),
        c = c_convolve(signal, kernel),
        check = FALSE
)    
  
```

## Dynamic Mojo Compilation

You can also compile and load Mojo code dynamically, similar to `callme::compile()`:

```{r, eval=TRUE}
# Create a simple Mojo file
mojo_code <- '
from sys.ffi import DLHandle, c_char, c_int
alias Rprintf_type = fn(fmt: UnsafePointer[c_char]) -> c_int
@export
fn multiply(x: Float64, y: Float64) -> Float64:
    return x * y

@export
fn greet(name: UnsafePointer[c_char]):
    try:
        var handle: DLHandle = DLHandle("")
        var Rprintf = handle.get_function[Rprintf_type]("Rprintf")
        _ = Rprintf(name)
    except:
        return
'

# Write to temporary file
temp_mojo <- tempfile(fileext = ".mojo")
writeLines(mojo_code, temp_mojo)

# Install Mojo in a temporary venv (only needed once)
venv_path <- tempfile(pattern = "mojo_venv_")
hellomojo::mojo_install(venv = venv_path, nightly = TRUE)

# Check the size of the Mojo installation
venv_size <- system2("du", c("-sh", venv_path), stdout = TRUE)
venv_size

# Compile the Mojo file and get R functions
hellomojo::mojo_compile(
  temp_mojo,
  venv = venv_path,
  verbosity = 1
)

# Now the @export functions are available:
multiply(6.0, 7.0)
greet("Hello from dynamically compiled Mojo!")

unlink(temp_mojo)
unlink(venv_path, recursive = TRUE)
```

## System and Device Information with Dynamic Compilation

Here's how to get comprehensive system and GPU device information using dynamic Mojo compilation:

```{r, eval=FALSE}
# Create Mojo code for system and device info
device_info_mojo <- '
from sys.ffi import DLHandle, c_char, c_int
import gpu.host
from sys import CompilationTarget, num_logical_cores, num_physical_cores
from sys.info import _triple_attr

alias Rprintf_type = fn(fmt: UnsafePointer[c_char]) -> c_int

fn compute_capability_to_arch_name(major: Int, minor: Int) -> String:
    if major == 1:
        return "tesla"
    if major == 2:
        return "fermi"
    if major == 3:
        return "kepler"
    # ... more architectures
    return "Unknown"

@export
fn system_info(device_id: Int32, api_name: UnsafePointer[c_char]):
    try:
        var handle: DLHandle = DLHandle("")
        var Rprintf = handle.get_function[Rprintf_type]("Rprintf")
        
        _ = Rprintf("=== System Information ===\\n")
        
        # CPU info always shown
        var os_name = "linux"  # simplified
        var cpu = CompilationTarget._arch()
        
        _ = Rprintf("CPU Information:\\n")
        var os_msg = "  OS             : " + os_name + "\\n"
        _ = Rprintf(os_msg.unsafe_ptr())
        var cpu_msg = "  CPU            : " + String(cpu) + "\\n"
        _ = Rprintf(cpu_msg.unsafe_ptr())
        
        # Try GPU info
        try:
            var api = String(api_name)
            var ctx = gpu.host.DeviceContext(Int(device_id), api=api)
            _ = Rprintf("\\nGPU Information:\\n")
            var name_msg = "  Name           : " + ctx.name() + "\\n"
            _ = Rprintf(name_msg.unsafe_ptr())
        except:
            _ = Rprintf("\\nGPU Information:\\n")
            _ = Rprintf("  Status         : No GPU detected\\n")
    except:
        pass
'

# Write to temporary file
temp_mojo_system <- tempfile(fileext = ".mojo")
writeLines(device_info_mojo, temp_mojo_system)

# Compile and load
hellomojo::mojo_compile(temp_mojo_system, venv = venv_path)

# Get comprehensive system info (CPU always, GPU when available)
system_info(0L, "cuda")

unlink(temp_mojo_system)
```

This parses the Mojo file, extracts all `@export` functions, generates C wrappers,
compiles everything, and creates R functions automatically. Only `UnsafePointer` types
and scalar Int/Float types are currently supported. This is quite brittle now. We should use a proper Mojo parser or dump MLIR representations like in this [gist](https://gist.github.com/soraros/44d56698cb20a6c5db3160f13ca81675)




## Limitations to investigate

The package now offers two approaches: the original pixi-based static compilation and a  dynamic compilation system using Python virtual environments. For compilation at installation time, we use pixi to get Mojo binaries, but installing this on the R Windows toolchain is not straightforward. We should consider using uv or creating an R package that installs pixi. Moreover, Windows support could not be added to the current pixi workspace (because Mojo only supports WSL). This package should work fine on Unix systems.

The dynamic compilation approach (`mojo_compile()`) provides a more lightweight alternative that only requires a Python virtual environment with Mojo installed, avoiding the need for pixi entirely. This makes the installation much more manageable and potentially Windows-compatible (if Mojo support windows).

We are calling the Mojo shared object in the same address space as R and calling the R C API from Mojo FFI, even though the toolchains are different. 

The main limitation remains that the pixi strategy downloads the entire Mojo runtime and toolchain (essentially installing LLVM), leading to a ~1GB install. The dynamic approach mitigates this by allowing users to manage Mojo installation separately at runtime(still big tough).


## References

- [Mojo Getting Started Guide](https://docs.modular.com/mojo/manual/get-started)  
- [pixi: Package and Environment Manager](https://pixi.sh/)
- [simpleCall example](https://github.com/coolbutuseless/simpleCall)